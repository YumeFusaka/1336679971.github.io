<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>背包问题</title>
      <link href="/2023/06/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2023/06/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-背包问题概述"><a href="#1-背包问题概述" class="headerlink" title="1 . 背包问题概述:"></a>1 . 背包问题概述:</h1><p>背包问题(Knapsack problem)是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种<br>物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的<br>名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂<br>性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过W的前提<br>下，总价值是否能达到V？它是在1978年由Merkle和Hellman提出的。</p><h1 id="2-背包算法原理"><a href="#2-背包算法原理" class="headerlink" title="2 . 背包算法原理:"></a>2 . 背包算法原理:</h1><p>太多了，懒得写</p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num[<span class="number">105</span>][<span class="number">5</span>],dp[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> T, M;</span><br><span class="line">cin &gt;&gt; T &gt;&gt; M;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">cin &gt;&gt; num[i][<span class="number">1</span>] &gt;&gt; num[i][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = T; j &gt;= num[i][<span class="number">1</span>]; j--)</span><br><span class="line"><span class="keyword">if</span> (j &gt;= num[i][<span class="number">1</span>])dp[j] = <span class="built_in">max</span>(dp[j], dp[j - num[i][<span class="number">1</span>]] + num[i][<span class="number">2</span>]);</span><br><span class="line">cout &lt;&lt; dp[T];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10005</span>][<span class="number">5</span>],dp[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> T, M;</span><br><span class="line">cin &gt;&gt; T &gt;&gt; M;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">cin &gt;&gt; num[i][<span class="number">1</span>] &gt;&gt; num[i][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = num[i][<span class="number">1</span>]; j &lt;= T; j++) </span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - num[i][<span class="number">1</span>]] + num[i][<span class="number">2</span>]);</span><br><span class="line">cout &lt;&lt; dp[T];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列</title>
      <link href="/2023/06/09/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>/2023/06/09/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-单调队列概述"><a href="#1-单调队列概述" class="headerlink" title="1 . 单调队列概述:"></a>1 . 单调队列概述:</h1><p>单调队列，可以用来维护（给定大小的）区间的最值，其时间复杂度为O(n)，其中n为序列的元素个数。<br>顾名思义，是一种具有单调性的队列。众所周知，单调性有单调递增和单调递减两种，相应的单调队列<br>也分为单调递增队列和单调递减队列两种。</p><h1 id="2-单调队列算法原理"><a href="#2-单调队列算法原理" class="headerlink" title="2 . 单调队列算法原理:"></a>2 . 单调队列算法原理:</h1><p>太多了，懒得写</p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = <span class="number">1e+6</span>;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt;big, small;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, k, num[lim + <span class="number">5</span>];</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cin &gt;&gt; num[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (big.<span class="built_in">empty</span>() == <span class="number">0</span> &amp;&amp; i - big.<span class="built_in">front</span>() &gt;= k)</span><br><span class="line">big.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="keyword">while</span> (big.<span class="built_in">empty</span>() == <span class="number">0</span> &amp;&amp; num[i] &lt;= num[big.<span class="built_in">back</span>()])</span><br><span class="line">big.<span class="built_in">pop_back</span>();</span><br><span class="line">big.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (i == k)</span><br><span class="line">cout &lt;&lt; num[big.<span class="built_in">front</span>()];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &gt; k)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num[big.<span class="built_in">front</span>()];</span><br><span class="line">&#125;cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (small.<span class="built_in">empty</span>() == <span class="number">0</span> &amp;&amp; i - small.<span class="built_in">front</span>() &gt;= k)</span><br><span class="line">small.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="keyword">while</span> (small.<span class="built_in">empty</span>() == <span class="number">0</span> &amp;&amp; num[i] &gt;= num[small.<span class="built_in">back</span>()])</span><br><span class="line">small.<span class="built_in">pop_back</span>();</span><br><span class="line">small.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (i == k)</span><br><span class="line">cout &lt;&lt; num[small.<span class="built_in">front</span>()];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &gt; k)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num[small.<span class="built_in">front</span>()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉筛</title>
      <link href="/2023/06/08/%E6%AC%A7%E6%8B%89%E7%AD%9B/"/>
      <url>/2023/06/08/%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-欧拉筛概述"><a href="#1-欧拉筛概述" class="headerlink" title="1 . 欧拉筛概述:"></a>1 . 欧拉筛概述:</h1><p>欧拉筛是一种快速求得区间素数的算法，可以达到O(n)的线性效率</p><h1 id="2-欧拉筛算法原理"><a href="#2-欧拉筛算法原理" class="headerlink" title="2 . 欧拉筛算法原理:"></a>2 . 欧拉筛算法原理:</h1><p>1.如果上界小于2，没有素数，返回。</p><p>2.标记i=2为第一个素数。然后如果没有到达上界，转移到步骤3，否则转移到步骤5。</p><p>3.令i自增1。检验i是否是素数，如果是素数,将其填入素数数组中，转移到步骤4。</p><p>4.无论它是不是素数，都将它与目前已经找到的素数的乘积判定为合数。如果某一个<br>素数可以被当前这个数 i 整除，或者所有已经选出的素数都已经遍历过，或者当前素<br>数*i后大于上界，转移到步骤5。</p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = <span class="number">1e+8</span>;</span><br><span class="line"><span class="type">int</span> prime[lim + <span class="number">5</span>], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> num[lim + <span class="number">5</span>]; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ora</span><span class="params">()</span> </span>&#123;</span><br><span class="line">num[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= lim; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (num[i] == <span class="literal">false</span>)</span><br><span class="line">prime[++cnt] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= lim; j++) &#123;</span><br><span class="line">num[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 质数筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>石子合并</title>
      <link href="/2023/06/08/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/"/>
      <url>/2023/06/08/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-石子合并概述"><a href="#1-石子合并概述" class="headerlink" title="1 . 石子合并概述:"></a>1 . 石子合并概述:</h1><p>动态规划算法是计算机算法设计中的一个重要算法，通过拆分问题，定义问题状态和状态之间的<br>关系，使得问题能够以递推的方式去解决，石子合并问题作为典型算例，能够彰显动态规划算法<br>特征。针对石子合并问题，本文利用动态规划算法寻求石子合并时的最大,最小得分，选择相邻<br>的两堆石子堆进行合并，其最终花费的代价与石子堆的排列顺序有关。根据其重叠子问题建立状<br>态转移方程，利用程序进行求解。算例结果显示：将4堆石子合并成一堆，每堆的石子个数分别是<br>4,4,5,9，合并的代价最小得分为43，最大得分为54。</p><h1 id="2-石子合并算法原理"><a href="#2-石子合并算法原理" class="headerlink" title="2 . 石子合并算法原理:"></a>2 . 石子合并算法原理:</h1><p>太多了，懒得写</p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = <span class="number">3e+2</span>;</span><br><span class="line">ll stone[lim+<span class="number">5</span>], sum[lim+<span class="number">5</span>], dp[lim+<span class="number">5</span>][lim+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++) &#123;</span><br><span class="line">cin &gt;&gt; stone[i];</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + stone[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (j &gt; n)<span class="keyword">break</span>;</span><br><span class="line">ll minn = <span class="number">0x3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = i; u &lt; j; u++) &#123;</span><br><span class="line">minn = <span class="built_in">min</span>(minn, dp[i][u] + dp[u + <span class="number">1</span>][j] + sum[j] - sum[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j] = minn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分数组</title>
      <link href="/2023/06/03/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"/>
      <url>/2023/06/03/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-差分数组概述"><a href="#1-差分数组概述" class="headerlink" title="1 . 差分数组概述:"></a>1 . 差分数组概述:</h1><p>针对数组中连续的大量数据进行修改的问题，如果我们对每个数据都进行依次修改，对于一些少<br>量的数据的修改（例如：1~100这些的），修改的时候我们发现速度貌似还是很快的，但是一旦<br>修改的连续数组中的数量上万了，那么修改的速率就明显下降了。针对这样的情况，就出现了差<br>分数组，也就是一个额外的数组（说白了，就是为了挽回时间效率而利用空间去开辟一个数组帮<br>我们更好的去管理一些数据），这个数组是为要改动的目标数组进行数据管理的。假设要管理的<br>数据为a，差分数组为d。对于不同的位置为i，那么对于差分数组而言，他每个位置的数为：d[i]<br>= a[i] - a[i-1]。（d与a对应的每个位置的数据关系为：d与a对应位置的数据等于a当前位置减<br>去a当前位置的上一个位置）</p><h1 id="2-差分数组算法原理"><a href="#2-差分数组算法原理" class="headerlink" title="2 . 差分数组算法原理:"></a>2 . 差分数组算法原理:</h1><p>太多了，懒得写</p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> upfor(i,a,n) for(int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> downfor(i,a,n) for(int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = <span class="number">500005</span>;</span><br><span class="line"><span class="type">int</span> n, m, tree[lim];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> add)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">tree[i] += add;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x; i &gt;= <span class="number">1</span>; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">sum += tree[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="type">int</span> a, x, y, k;</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>, ago = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">upfor</span>(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">cin &gt;&gt; now;</span><br><span class="line"><span class="built_in">update</span>(i, now - ago);</span><br><span class="line">ago = now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">upfor</span>(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line"><span class="built_in">update</span>(x, k);</span><br><span class="line"><span class="built_in">update</span>(y + <span class="number">1</span>, <span class="number">-1</span> * k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(x) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kmp</title>
      <link href="/2023/06/01/Kmp/"/>
      <url>/2023/06/01/Kmp/</url>
      
        <content type="html"><![CDATA[<h1 id="1-kmp算法概述"><a href="#1-kmp算法概述" class="headerlink" title="1 . kmp算法概述:"></a>1 . kmp算法概述:</h1><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，<br>因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配<br>失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通<br>过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度为<br>O(m+n)也就是说，KMP算法是用来解决字符串匹配问题的，从一个主字符串text中寻找一个<br>子字符串(模式字符串)pattern，看这个子串是否在主串中，比如对于text=’abaacababca<br>c’和pattern=’ababc’，子串是包含在主串中的，同时它在主串中的索引是5。</p><h1 id="2-kmp算法原理"><a href="#2-kmp算法原理" class="headerlink" title="2 . kmp算法原理:"></a>2 . kmp算法原理:</h1><p>太多了，懒得写</p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = <span class="number">1e+6</span>;</span><br><span class="line"><span class="type">int</span> Next[lim+<span class="number">5</span>], lena, lenb;</span><br><span class="line">string a, b, emt = <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= lenb; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; b[i] != b[j + <span class="number">1</span>])</span><br><span class="line">j = Next[j];</span><br><span class="line"><span class="keyword">if</span> (b[i] == b[j + <span class="number">1</span>])</span><br><span class="line">j++;</span><br><span class="line">Next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= lena; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; a[i] != b[j + <span class="number">1</span>])</span><br><span class="line">j = Next[j];</span><br><span class="line"><span class="keyword">if</span> (a[i] == b[j + <span class="number">1</span>])</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">if</span> (j == lenb) &#123;</span><br><span class="line">j = Next[j];</span><br><span class="line">cout &lt;&lt; i - lenb + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">a = emt + a, b = emt + b;</span><br><span class="line">lena = a.<span class="built_in">length</span>() - <span class="number">1</span>, lenb = b.<span class="built_in">length</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cNext</span>();</span><br><span class="line"><span class="built_in">kmp</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kruskal</title>
      <link href="/2023/06/01/Kruskal/"/>
      <url>/2023/06/01/Kruskal/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Kruskal算法概述"><a href="#1-Kruskal算法概述" class="headerlink" title="1 . Kruskal算法概述:"></a>1 . Kruskal算法概述:</h1><p>Kruskal是求连通网的最小生成树的一种方法。假设连通网G=（V，E），令最小生<br>成树的初始状态为只有n个顶点而无边的非连通图T=（V，{}），概述图中每个顶点<br>自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点分别在T中不同的<br>连通分量上，则将此边加入到T中；否则，舍去此边而选择下一条代价最小的边。依<br>此类推，直至T中所有顶点构成一个连通分量为止。</p><h1 id="2-Kruskal算法原理"><a href="#2-Kruskal算法原理" class="headerlink" title="2 . Kruskal算法原理:"></a>2 . Kruskal算法原理:</h1><p>太多了，懒得写</p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = <span class="number">2e+5</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge&amp; t)&amp; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;w &lt; t.w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt;edge;</span><br><span class="line"><span class="type">int</span> fa[lim+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lim; i++)</span><br><span class="line">fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFa</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fa[a] == a)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> fa[a] = <span class="built_in">findFa</span>(fa[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">fa[<span class="built_in">findFa</span>(a)] = <span class="built_in">findFa</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isParent</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">findFa</span>(a) == <span class="built_in">findFa</span>(b))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : edge) &#123;</span><br><span class="line">a = i.u, b = i.v;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isParent</span>(a, b))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">merge</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="type">int</span> n, m, u, v, w;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">edge.<span class="built_in">emplace_back</span>(Edge&#123; u,v,w &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(edge.<span class="built_in">begin</span>(), edge.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">kruskal</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie字典树</title>
      <link href="/2023/06/01/Trie%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2023/06/01/Trie%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Trie字典树概述"><a href="#1-Trie字典树概述" class="headerlink" title="1 . Trie字典树概述:"></a>1 . Trie字典树概述:</h1><p>字典树（Trie）是一种空间换时间的数据结构，是一棵关于“字典”的树。主要用于统计、排序<br>和保存大量的字符串。字典树是通过利用字符串的公共前缀来节约存储空间，因此字典树又叫<br>前缀树。字典树是对于字典的一种存储方式。这个词典中的每个“单词”就是从根节点出发一直<br>到某一个目标节点的路径，路径中每条边的字母连起来就是一个单词。</p><h1 id="2-Trie字典树算法原理"><a href="#2-Trie字典树算法原理" class="headerlink" title="2 . Trie字典树算法原理:"></a>2 . Trie字典树算法原理:</h1><p>太多了，懒得写</p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nodes</span> &#123;</span><br><span class="line"><span class="type">int</span> son[<span class="number">26</span>];</span><br><span class="line"><span class="type">bool</span> mark;</span><br><span class="line">&#125;trie[<span class="number">10001</span>];</span><br><span class="line"><span class="type">int</span> root = <span class="number">0</span>, num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert_check</span><span class="params">(<span class="type">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> position = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line"><span class="type">int</span> symbol = (<span class="type">int</span>)str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!trie[position].son[symbol]) </span><br><span class="line">trie[position].son[symbol] = ++num;</span><br><span class="line">position = trie[position].son[symbol]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> temp = trie[position].mark;</span><br><span class="line">trie[position].mark = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> temp != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">char</span>* str)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> pos = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line"><span class="type">int</span> x = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (trie[pos].son[x] == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">pos = trie[pos].son[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串Hash</title>
      <link href="/2023/06/01/%E5%AD%97%E7%AC%A6%E4%B8%B2Hash/"/>
      <url>/2023/06/01/%E5%AD%97%E7%AC%A6%E4%B8%B2Hash/</url>
      
        <content type="html"><![CDATA[<h1 id="1-字符串Hash概述"><a href="#1-字符串Hash概述" class="headerlink" title="1 . 字符串Hash概述:"></a>1 . 字符串Hash概述:</h1><p>散列表(Hash table,也叫哈希表)，是根据键(Key)而直接访问在内存储存位置的数据结构。也就<br>是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加<br>快了查找速度当我们要对若干复杂信息进行统计时，可以用Hash函数把这些复杂信息映射到一个容<br>易维护的值域内。当N过于大时，我们可以设计Hash函数为H(x)=(x mod P)+1，其中P是一个较大<br>的质数，但不超过N，这样这个Hash函数就把数列A AA中的值映射到了不同的区域进行储存，然后<br>继续进行后面的操作。总的来说， 其基本原理是：使用一个下标范围比较大的数组来存储元素。<br>可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数<br>组下标，hash值）相对应，于是用这个数组单元来存储这个元素。</p><h1 id="2-字符串Hash算法原理"><a href="#2-字符串Hash算法原理" class="headerlink" title="2 . 字符串Hash算法原理:"></a>2 . 字符串Hash算法原理:</h1><p>太多了，懒得写</p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> llu = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = <span class="number">1e+4</span>;</span><br><span class="line"><span class="type">const</span> llu mod = <span class="number">213142412546341</span>;</span><br><span class="line"><span class="type">const</span> llu prime = <span class="number">200404141</span>;</span><br><span class="line"><span class="type">const</span> llu base = <span class="number">131</span>;</span><br><span class="line">llu Hash[lim + <span class="number">5</span>];</span><br><span class="line"><span class="function">llu <span class="title">init</span><span class="params">(string x)</span> </span>&#123;</span><br><span class="line">llu sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : x)</span><br><span class="line">sum = (sum * base + i - <span class="string">&#x27;0&#x27;</span>) % mod;</span><br><span class="line"><span class="keyword">return</span> sum + prime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">string x;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">Hash[i] = <span class="built_in">init</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPFA</title>
      <link href="/2023/06/01/SPFA/"/>
      <url>/2023/06/01/SPFA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-SPFA算法概述"><a href="#1-SPFA算法概述" class="headerlink" title="1 . SPFA算法概述:"></a>1 . SPFA算法概述:</h1><p>SPFA算法的全称是：Shortest Path Faster Algorithm，是西南交通大学段凡丁于<br>1994 年发表的论文中的名字。不过，段凡丁的证明是错误的，且在 Bellman-Ford<br>算法提出后不久（1957 年）已有队列优化内容，所以国际上不承认 SPFA 算法是段凡<br>丁提出的。为了避免最坏情况的出现，在正权图上应使用效率更高的Dijkstra算法。若<br>给定的图存在负权边，类似Dijkstra算法等算法便没有了用武之地，SPFA算法便派上用<br>场了。</p><h1 id="2-SPFA算法原理"><a href="#2-SPFA算法原理" class="headerlink" title="2 . SPFA算法原理:"></a>2 . SPFA算法原理:</h1><p>我们约定加权有向图G不存在负权回路，即最短路径一定存在。用数组d记录每个结点的最<br>短路径估计值，而且用邻接表来存储图G。我们采取的方法是动态逼近法：设立一个先进先<br>出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径<br>估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v<br>点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。</p><p>定理：只要最短路径存在，上述SPFA算法必定能求出最小值。证明：每次将点放入队尾，都<br>是经过松弛操作达到的。换言之，每次的优化将会有某个点v的最短路径估计值d[v]变小。<br>所以算法的执行会使d越来越小。由于我们假定图中不存在负权回路，所以每个结点都有最短<br>路径值。因此，算法不会无限执行下去，随着d值的逐渐变小，直到到达最短路径值时，算法<br>结束，这时的最短路径估计值就是对应结点的最短路径值。</p><p>实际上，如果一个点进入队列达到n次，则表明图中存在负环，没有最短路径。段凡丁论文<br>中的复杂度证明 （O(kE)，k 是小常数）是错误的，在此略去。该算法的最坏时间复杂度<br>为 O(VE)。对SPFA的一个很直观的理解就是由无权图的BFS转化而来。在无权图中，BFS首<br>先到达的顶点所经历的路径一定是最短路(也就是经过的最少顶点数)，所以此时利用数组记<br>录节点访问可以使每个顶点只进队一次，但在带权图中，最先到达的顶点所计算出来的路径<br>不一定是最短路。一个解决方法是放弃数组，此时所需时间自然就是指数级的，所以我们不<br>能放弃数组，而是在处理一个已经在队列中且当前所得的路径比原来更好的顶点时，直接更<br>新最优解。</p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = <span class="number">5e+5</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> to, next, w;</span><br><span class="line">&#125;edge[lim+<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> head[lim+<span class="number">5</span>], dis[lim+<span class="number">5</span>], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> vis[lim+<span class="number">5</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; ss;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lim; i++)</span><br><span class="line">dis[i] = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++cnt].to = v;</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> Start)</span> </span>&#123;</span><br><span class="line">dis[Start] = <span class="number">0</span>;</span><br><span class="line">ss.<span class="built_in">emplace</span>(Start);</span><br><span class="line"><span class="keyword">while</span> (ss.<span class="built_in">empty</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> now = ss.<span class="built_in">front</span>();</span><br><span class="line">ss.<span class="built_in">pop</span>();</span><br><span class="line">vis[now] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head[now]; ~i; i = edge[i].next) &#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span> (dis[v] &gt; edge[i].w + dis[now]) &#123;</span><br><span class="line">dis[v] = edge[i].w + dis[now];</span><br><span class="line"><span class="keyword">if</span> (vis[v] == <span class="number">0</span>) </span><br><span class="line">ss.<span class="built_in">emplace</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="type">int</span> n, m, s, u, v, w;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m;i++) &#123;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="built_in">addEdge</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SPFA</span>(s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/2023/06/01/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2023/06/01/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-树状数组概述"><a href="#1-树状数组概述" class="headerlink" title="1 . 树状数组概述:"></a>1 . 树状数组概述:</h1><p>树状数组或二叉索引树（英语：Binary Indexed Tree），又以其发明者命名为Fenwick树<br>，最早由Peter M. Fenwick于1994年以A New Data Structure for Cumulative Frequ<br>ency Tables为题发表在SOFTWARE PRACTICE AND EXPERIENCE。其初衷是解决数据压缩里<br>的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。</p><h1 id="2-树状数组算法原理"><a href="#2-树状数组算法原理" class="headerlink" title="2 . 树状数组算法原理:"></a>2 . 树状数组算法原理:</h1><p>太多了，懒得写</p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = <span class="number">5e+5</span>;</span><br><span class="line"><span class="type">int</span> tree[lim + <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> n, m, k, x, y, t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> add)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">tree[i] += add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x; i &gt;= <span class="number">1</span>; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">sum += tree[i];</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line"><span class="built_in">update</span>(i, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; k;</span><br><span class="line"><span class="built_in">update</span>(x, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(y) - <span class="built_in">query</span>(x - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2023/06/01/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2023/06/01/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="1-线段树概述"><a href="#1-线段树概述" class="headerlink" title="1 . 线段树概述:"></a>1 . 线段树概述:</h1><p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中<br>的一个叶结点。对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子<br>表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。<br>使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空<br>间复杂度为2N，因此有时需要离散化让空间压缩。</p><h1 id="2-线段树算法原理"><a href="#2-线段树算法原理" class="headerlink" title="2 . 线段树算法原理:"></a>2 . 线段树算法原理:</h1><p>太多了，懒得写</p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = <span class="number">1e+5</span>;</span><br><span class="line">ll rmq[lim * <span class="number">4</span>], num[lim + <span class="number">5</span>], lazy[lim * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(ll id)</span> </span>&#123;</span><br><span class="line">rmq[id] = rmq[id &lt;&lt; <span class="number">1</span>] + rmq[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(ll l, ll r, ll id)</span> </span>&#123;</span><br><span class="line">ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">lazy[id &lt;&lt; <span class="number">1</span>] += lazy[id];</span><br><span class="line">lazy[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += lazy[id];</span><br><span class="line">rmq[id &lt;&lt; <span class="number">1</span>] += (mid - l + <span class="number">1</span>) * lazy[id];</span><br><span class="line">rmq[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += (r - mid) * lazy[id];</span><br><span class="line">lazy[id] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll l,ll r,ll id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">rmq[id] = num[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(l, mid, id &lt;&lt; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">build</span>(mid + <span class="number">1</span>, r, id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line"><span class="built_in">pushup</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll l, ll r, ll x, ll y, ll id, ll add)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == x &amp;&amp; r == y) &#123;</span><br><span class="line">rmq[id] += (r - l + <span class="number">1</span>) * add;</span><br><span class="line">lazy[id] += add;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(l, r, id);</span><br><span class="line">ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= y)</span><br><span class="line"><span class="built_in">update</span>(l, mid, x, y, id &lt;&lt; <span class="number">1</span>, add);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; x)</span><br><span class="line"><span class="built_in">update</span>(mid + <span class="number">1</span>, r, x, y, id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, add);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">update</span>(l, mid, x, mid, id &lt;&lt; <span class="number">1</span>, add);</span><br><span class="line"><span class="built_in">update</span>(mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, y, id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, add);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll l, ll r, ll x, ll y, ll id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == x &amp;&amp; r == y)</span><br><span class="line"><span class="keyword">return</span> rmq[id];</span><br><span class="line"><span class="built_in">pushdown</span>(l, r, id);</span><br><span class="line">ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (mid &gt;= y)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(l, mid, x, y, id &lt;&lt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; x)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(mid + <span class="number">1</span>, r, x, y, id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(l, mid, x, mid, id &lt;&lt; <span class="number">1</span>) + <span class="built_in">query</span>(mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, y, id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ll n, m, a, x, y, k;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cin &gt;&gt; num[i];</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line"><span class="built_in">update</span>(<span class="number">1</span>, n, x, y, <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, n, x, y, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCA</title>
      <link href="/2023/06/01/LCA/"/>
      <url>/2023/06/01/LCA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-LCA算法概述"><a href="#1-LCA算法概述" class="headerlink" title="1 . LCA算法概述:"></a>1 . LCA算法概述:</h1><p>LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。<br>对于有根树T的两个结点u、v，最近公共祖先LCA(T,u,v)表示一个结点x，满足x是u、v的祖先且x的深度尽可能大。<br>另一种理解方式是把T理解为一个无向无环图，而LCA(T,u,v)即u到v的最短路上深度最小的点。</p><h1 id="2-LCA算法原理"><a href="#2-LCA算法原理" class="headerlink" title="2 . LCA算法原理:"></a>2 . LCA算法原理:</h1><p>太多了，懒得写</p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = <span class="number">5e+5</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> to, next;</span><br><span class="line">&#125;edge[(lim + <span class="number">5</span>) &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[lim + <span class="number">5</span>], cnt = <span class="number">0</span>, fa[lim + <span class="number">5</span>][<span class="number">21</span>], dep[lim + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lim; i++)</span><br><span class="line">fa[i][<span class="number">0</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[++cnt].to = v;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">edge[++cnt].to = u;</span><br><span class="line">edge[cnt].next = head[v];</span><br><span class="line">head[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">fa[s][<span class="number">0</span>] = f, dep[s] = dep[f] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= dep[s]; i++)</span><br><span class="line">fa[s][i] = fa[fa[s][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head[s]; i; i = edge[i].next) &#123;</span><br><span class="line"><span class="type">int</span> t = edge[i].to;</span><br><span class="line"><span class="keyword">if</span> (t == f)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(t, s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[x] &lt; dep[y])</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (dep[fa[x][i]] &gt;= dep[y])x = fa[x][i];</span><br><span class="line"><span class="keyword">if</span> (x == y)<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line"><span class="keyword">if</span> (fa[x][i] != fa[y][i]) </span><br><span class="line">x = fa[x][i], y = fa[y][i];</span><br><span class="line"><span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, s, a, b;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">addEdge</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">cout &lt;&lt; <span class="built_in">LCA</span>(a,b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最近公共祖宗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ST表</title>
      <link href="/2023/06/01/ST%E8%A1%A8/"/>
      <url>/2023/06/01/ST%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-ST表算法概述"><a href="#1-ST表算法概述" class="headerlink" title="1 . ST表算法概述:"></a>1 . ST表算法概述:</h1><p>ST表（Sparse Table，稀疏表）是一种简单的数据结构，主要用来解决<br>RMQ（Range Maximum/Minimum Query，区间最大/最小值查询）问题。<br>它主要应用倍增的思想，可以实现O(nlogn)预处理、O(1)查询。</p><h1 id="2-ST表算法原理"><a href="#2-ST表算法原理" class="headerlink" title="2 . ST表算法原理:"></a>2 . ST表算法原理:</h1><p>太多了，懒得写</p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = <span class="number">1e+5</span>;</span><br><span class="line"><span class="type">int</span> Log[lim], bin[<span class="number">31</span>], st[lim][<span class="number">31</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">bin[<span class="number">0</span>] = <span class="number">1</span>, Log[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lim; i++)</span><br><span class="line">Log[i] = Log[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++)</span><br><span class="line">bin[i] = bin[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">creatST</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j + bin[i] - <span class="number">1</span> &lt;= lim; j++)</span><br><span class="line">st[j][i] = <span class="built_in">max</span>(st[j][i - <span class="number">1</span>], st[j + bin[i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> t = Log[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(st[l][t], st[r - bin[t] + <span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, l, r;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cin &gt;&gt; st[i][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="built_in">creatST</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra(堆优化)</title>
      <link href="/2023/05/31/Dijkstra/"/>
      <url>/2023/05/31/Dijkstra/</url>
      
        <content type="html"><![CDATA[<p class='p center logo large'>Dijkstra算法</p><p class='p center small'>图论:单源最短路</p><div class="note info simple"><p>这是一篇讲解单源最短路算法<span class='p red'>Dijkstra</span>的文章,阅读前先了解图的数据结构(带权图,无向图,有向图)</p></div><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 . 概念:"></a>1 . 概念:</h1><h2 id="1-1-单源最短路"><a href="#1-1-单源最短路" class="headerlink" title="1 .1 单源最短路:"></a>1 .1 单源最短路:</h2><p>给定一个带权有向图G=（V,E），其中每条边的权是一个实数。另外，还给定V中的一个顶点，称为源。<br>要计算从源到其他所有各顶点的最短路径长度。这里的长度就是指路上各边权之和。这个问题通常称<br>为单源最短路径问题。</p><h2 id="1-2-Dijkstra"><a href="#1-2-Dijkstra" class="headerlink" title="1 .2 Dijkstra"></a>1 .2 Dijkstra</h2><p>迪杰斯特拉算法(Dijkstra),是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。<br>迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶<br>点的邻接节点，直到扩展到终点为止。<br><div class="note info simple"><p>需要注意的是，dijkstra算法只能解决正权图问题。</p></div></p><h1 id="2-算法原理与实现"><a href="#2-算法原理与实现" class="headerlink" title="2 . 算法原理与实现:"></a>2 . 算法原理与实现:</h1><p>我们使用<span class='p red'>链式前向星存图</span>，存储每一条边，以edge数组作为容器<br>edge的下标是cnt，而不是节点名称，cnt作为该条边的编号，规定cnt单增，每一条新的边的编号都是当前cnt+1<br>edge[cnt].to的值表示这条边指向的目标点<br>edge[cnt].next的值是一个cnt,它指向的是下一个与起点连接的节点的cnt<br>如果该节点不指向任何一个节点，那么规定next 的值为-1<br>edge[cnt].w指的是边的权值<br>head数组存储每一个点存储的第一条边的编号，下标就是该点的编号<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> to, next, w;</span><br><span class="line">&#125;edge[Num];</span><br><span class="line"><span class="type">int</span> head[Num], dis[Num], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> vis[Num];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++cnt].to = v;</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>将所有点归类为两个点集，点集A存储还未找到最短路径的点，点集B则存储已找到最短路的点。<br>我们创建一个Bool类型vis数组区分每一个点在哪个点集，若为false则说明在A点集，为true则在B点集，<br>初始所有点的vis默认为false(bool数组的特性，在不初始化时，默认值都为false)<br>然后设置数组dis，表示源点到每个点距离，在初始时，我们将源点距离设置为0，并将vis设置为true，<br>其他所有点的距离用memset设置为<span class='p red'>0x3f</span>(memst函数的赋值方式是逐字节的，而int类型<br>占4个字节，故memset会将每一个点的距离设置为0x3f3f3f3f，这是一个极大数，用来表示目前无法到达该点)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dis[Num];</span><br><span class="line"><span class="type">bool</span> vis[Num];</span><br><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">dis[Start] = <span class="number">0</span>;</span><br><span class="line">vis[Start] = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><hr><p>由于Dijkstra算法是一种贪心算法，要将当前点集B的所有边进行排序，选出终点不在点集B而且距离最短的边，<br>使用传统容器每次存储后需要进行排序，这种遍历行为的时间复杂度是O(N)级别，而Dijkstra算法本身就需要<br>进行O(N)次选点，这样下来总的时间复杂度是O(N^2)级别的，我们能否将其优化，使得将边排序的复杂度降低?<br>这就需要一个名为堆的数据结构了，堆是一种完全二叉树，是以自上而下升序(降序)的方式排列，插入的复杂度<br>是O(logN)级别，我们需要的是当前最短的边，因此选择小根堆(升序)，C++中的stl中含有一个名为优先队列(priority_queue)的容器内部实现就是堆，所以我们可以直接使用，在堆中存储对组(点的距离，点的编号)<br>，为了方便，我们用pii命名pair&lt; int, int&gt;。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line">priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; heap;</span><br></pre></td></tr></table></figure></p><hr><p>最后便是Dijkstra算法的具体实现，基本原理就是每次存入一个距离源点最短的点，将距离和编号放入堆，然后<br>查询放入点后源点能到达所有点中，距离最短的点，重复操作，直至所有点都进入点集B，则算法完成<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> Start)</span> </span>&#123;</span><br><span class="line">heap.<span class="built_in">emplace</span>(dis[Start], Start);</span><br><span class="line"><span class="keyword">while</span>(heap.<span class="built_in">empty</span>()==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">auto</span> now = heap.<span class="built_in">top</span>();</span><br><span class="line"><span class="keyword">if</span> (vis[now.second])&#123;</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[now.second] = <span class="literal">true</span>;</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head[now.second]; ~i; i = edge[i].next) &#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span> (dis[v] &gt; edge[i].w + dis[now.second]) &#123;</span><br><span class="line">dis[v] = edge[i].w + dis[now.second];</span><br><span class="line">heap.<span class="built_in">emplace</span>(dis[v], v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-代码总览"><a href="#3-代码总览" class="headerlink" title="3 . 代码总览:"></a>3 . 代码总览:</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> lim = <span class="number">2e+5</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> to, next, w;</span><br><span class="line">&#125;edge[lim+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line">priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; heap;</span><br><span class="line"><span class="type">int</span> head[lim+<span class="number">5</span>], dis[lim+<span class="number">5</span>], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> vis[lim+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">edge[++cnt].to = v;</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> Start)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">dis[Start] = <span class="number">0</span>;</span><br><span class="line">heap.<span class="built_in">emplace</span>(dis[Start], Start);</span><br><span class="line"><span class="keyword">while</span> (heap.<span class="built_in">empty</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">auto</span> now = heap.<span class="built_in">top</span>();</span><br><span class="line"><span class="keyword">if</span> (vis[now.second]) &#123;</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[now.second] = <span class="literal">true</span>;</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head[now.second]; ~i; i = edge[i].next) &#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span> (dis[v] &gt; edge[i].w + dis[now.second]) &#123;</span><br><span class="line">dis[v] = edge[i].w + dis[now.second];</span><br><span class="line">heap.<span class="built_in">emplace</span>(dis[v], v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="built_in">addEdge</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dijkstra</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)cout &lt;&lt; dis[i];</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; dis[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>感谢你的观看</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到梦浮坂</title>
      <link href="/2023/05/29/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%A2%A6%E6%B5%AE%E5%9D%82/"/>
      <url>/2023/05/29/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%A2%A6%E6%B5%AE%E5%9D%82/</url>
      
        <content type="html"><![CDATA[<font size = 4,font color=pink>Ciallo～(∠・ω< )⌒★ 我是MonPanache，欢迎来到我的小站，这是我的个人空间，也是我时光的记录簿我将在这里记录下我生活中经历的点点滴滴，与追逐梦想的历程，希望大家共同见证这个网站与我的成长</font>]]></content>
      
      
      <categories>
          
          <category> 本站简介 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
